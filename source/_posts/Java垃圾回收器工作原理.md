---
title: Java垃圾回收器工作原理
tags: []
date: 2013-01-07 11:07:00
---

垃圾回收器是如何工作的？我现在就简单的介绍一下

首先要明确几点：

Java是在堆上为对象分配空间的

垃圾回收器只跟内存有关，什么IO啊，网络连接啊，管它P事

当可用内存数量较低时，Sun版本的垃圾回收器才会被激活

在垃圾回收器回收垃圾之前，我们先来了解一下Java分配对象的方式，Java的堆更像一个传送带，每分配一个新对象，它就往前移动一格。这意味着对象存储空间的分配速度相当快。Java的&ldquo;堆指针&rdquo;只是简单地移动到尚未分配的领域。也就是说，分配空间的时候，&ldquo;堆指针&rdquo;只管依次往前移动而不管后面的对象是否还要被释放掉。如果可用内存耗尽之前程序就退出就再好不过了，这样的话垃圾回收器压根就不会被激活。

但是由于&ldquo;堆指针&rdquo;只管依次往前移动，那么你肯定会想，总有一天内存会被耗尽，垃圾回收器就开始释放内存。这里有人肯定会问：怎么判断某个对象该被回收呢？答案就是当堆栈或静态存储区没有对这个对象的引用时，就表示程序（员）对这个对象没有兴趣了，它就应该被回收了。有两种方法来知道这个对象有没有被引用：第一种是遍历堆上的对象找引用；第二种是遍历堆栈或静态存储区的引用找对象。前者的实现叫做&ldquo;引用计数法&rdquo;，意思就是当有引用连接至对象时，引用计数加1，当引用离开作用域或被置为null时，引用计数减1，这种方法有个缺陷，如果对象之间存在循环引用，可能会出现&ldquo;对象应该被回收，但引用计数却不为零&rdquo;的情况。

Java采用的是后者，在这种方式下，Java虚拟机采用一种&ldquo;自适应&rdquo;的垃圾回收技术，如何处理找到的存活对象（也就是说不是垃圾），Java有两种方式：

一种是&ldquo;停止-复制&rdquo;：理论上是先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全是垃圾。当对象被复制到新堆上时，它们是一个挨着一个的，所以新堆保持紧凑排列（这也是为什么分配对象的时候&ldquo;堆指针&rdquo;只管依次往前移动）。然后就可以按前述方法简单、直接地分配内存了。这将导致大量内存复制行为，内存分配是以较大的&ldquo;块&rdquo;为单位的。有了块之后，垃圾回收器就可以不往堆里拷贝对象了，直接就可以往废弃的块里拷贝对象了。

另一种是&ldquo;标记-清扫&rdquo;：它的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象一个标记。这个过程中不会回收任何对象。只有全部标记完成时，没有标记的对象将被释放，不会发生任何复制工作，所以剩下的堆空间是不连续的，然后垃圾回收器重新整理剩余的对象，使它们是连续排列的。

当垃圾回收器第一次启动时，它执行的是&ldquo;停止-复制&rdquo;，因为这个时刻内存有太多的垃圾。然后Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到&ldquo;标记-清扫&rdquo;方式；同样，Java虚拟机会跟踪&ldquo;标记-清扫&rdquo;效果，要是堆空间出现很多碎片，就会切换到&ldquo;停止-复制&rdquo;方式。这就是所谓的&ldquo;自适应&rdquo;技术。

其实仔细想一下，&ldquo;停止-复制&rdquo;和&ldquo;标记-清扫&rdquo;无非就是：&ldquo;在大量的垃圾中找干净的东西和在大量干净的东西里找垃圾&rdquo;。不同的环境用不同的方式，这样做完全是为了提高效率，要知道，无论哪种方式，Java都会先暂停程序的运行，所以，垃圾回收器的效率其实是很低的。Java用效率换回了C++没有的垃圾回收器和运行时的灵活，我认为这是明智的选择（虽然它只跟内存有关），随着硬件的飞速发展，我相信，开发时间要比运行效率重要得多！

引用：[http://fhz1980.blog.163.com/blog/](http://fhz1980.blog.163.com/blog/)